# ---------------------------------------------------------------------------# --- Description --# Library containing methods required for other post-processing related tasks# image features.# ------------------# Authors: Doruk Aksoy; University of California, Irvine# Contact: (daksoy@uci.edu)# Date: 06/27/2023# ------------------# Version: Python 3.8# ---------------------------------------------------------------------------# %% Importsimport numpy as npimport math# Custom Librariesimport CRFLib as crf# %% Methods# Calculate angle in radians    def calcAngleInRads(central,neighbor):    # Warning: y is reversed due to the direction of the array vs image    return math.atan2(-(central[0]-neighbor[0]), central[1]-neighbor[1])  # A function to convert the absolute coordinates to relative coordinates within the field for a sinkdef sink_abs_to_rel(sinks_abs, source_abs, source_rel):    source_abs_y, source_abs_x = source_abs    sink_abs_y, sink_abs_x = sinks_abs    source_rel_y, source_rel_x = source_rel        # Find the difference between absolute and relative coordinates of the source    y_diff = source_abs_y - source_rel_y    x_diff = source_abs_x - source_rel_x        # Apply those differences to absolute sink coordinates to obtain relative coordinates    y_rel, x_rel = sink_abs_y - y_diff, sink_abs_x - x_diff    return (y_rel, x_rel)def classify_pixels(image, **kwargs):        classified_image = np.zeros_like(image, dtype=np.uint8)    classified_image[image == 1] = 1 # Complete segments        if "triple_junctions" in kwargs:        classified_image[kwargs["triple_junctions"]] = 2    if "broken_segments" in kwargs:        classified_image[kwargs["broken_segments"].astype(bool)] = 3    if "iso_points" in kwargs:        classified_image[kwargs["iso_points"]] = 4    return classified_image# Remove padding from the imagedef remove_padding(image, pad_size=32):    return image[pad_size:-pad_size, pad_size:-pad_size]# %% Address near edge broken segmentsdef connect_near_edge_broken_segments(iso_points, broken_segments, labeled_complete_segments, image_shape, near_edge_dist=10):       # Iterate through each isolated point in the iso_points dict    for lj, angle in iso_points.items():        y, x = lj        height, width = image_shape                # Check if the isolated point is near any edge        if y < near_edge_dist or x < near_edge_dist or y > height - near_edge_dist or x > width - near_edge_dist:            # Identify the broken segment the isolated point is on and connect it to the edge, which makes it a complete segment            for idx, segment in broken_segments.items():                if lj == segment[0] or lj == segment[-1]:                    # Calculate the point on the edge and its angle                    if y < near_edge_dist:                        edge_point = (0, x)                    elif x < near_edge_dist:                        edge_point = (y, 0)                    elif y > height - near_edge_dist:                        edge_point = (height - 1, x)                    elif x > width - near_edge_dist:                        edge_point = (y, width - 1)                                                                # Connect the broken segment and edge iso_point with a new label that comes after the last label in complete segments                    last_complete_segment_label = np.unique(labeled_complete_segments)[-1]                    labeled_complete_segments[edge_point] = last_complete_segment_label + 1 # Label the edge point                    # Label the line                    if lj == segment[0]:                        for point in crf.line(edge_point, segment[0]):                            labeled_complete_segments[point] = last_complete_segment_label + 1                    else:                        for point in crf.line(edge_point, segment[-1]):                            labeled_complete_segments[point] = last_complete_segment_label + 1                                        # Then, label the broken segment as complete segment                     for point in segment:                        labeled_complete_segments[point] = last_complete_segment_label + 1        # Assign 1 to edges     labeled_complete_segments[0, :] = 1    labeled_complete_segments[-1, :] = 1    labeled_complete_segments[:, 0] = 1    labeled_complete_segments[:, -1] = 1                    return labeled_complete_segments# %% Match the broken segment labels with 'labeled_broken_segments' array.   def match_labels(broken_labels, on_broken_idxs, iso_points, tagged_iso_points, broken_segments, labeled_broken_segments, labeled_complete_segments, tagged_triple_junctions, title):    # Identify the idxs of broken_labels that we do not want to keep    off_broken_idxs = [i for i in range(len(broken_labels)) if i not in on_broken_idxs]    labels_not_to_keep = [broken_labels[i] for i in off_broken_idxs]        # Iterate over the 2D array and set the labels to 0 if they are in off_broken_segments    labeled_broken_segments_post3 = labeled_broken_segments.copy()    for j in range(labeled_broken_segments_post3.shape[0]):        for i in range(labeled_broken_segments_post3.shape[1]):            if labeled_broken_segments_post3[j, i] in labels_not_to_keep:                labeled_broken_segments_post3[j, i] = 0    # Remove the isolated points from the dict if their broken segment is not on        iso_points_post3 = iso_points.copy()    for index in off_broken_idxs:         # Get the first and last points from the corresponding value in broken_segments        first_point = broken_segments[index][0]        last_point = broken_segments[index][-1]                # Check if the first or last points are a key in iso_points        if first_point in iso_points_post3:            # Remove this key-value pair from iso_points            del iso_points_post3[first_point]                if last_point in iso_points_post3:            # Remove this key-value pair from iso_points            del iso_points_post3[last_point]    # Match the iso_points in iso_points array, and remove the ones with off broken segments    tagged_iso_points_post3 = tagged_iso_points.copy()    for key in iso_points:        if key not in iso_points_post3:            # Assign False to the corresponding position in iso_points            y, x = key            tagged_iso_points_post3[y,x] = False    # Reconstruct the image with the 'on' broken segments and corresponding isolated points    tagged_post3 = np.zeros_like(labeled_complete_segments, dtype=np.uint8)    tagged_post3 = labeled_complete_segments + tagged_triple_junctions + labeled_broken_segments_post3 + tagged_iso_points_post3    tagged_post3 = np.clip(tagged_post3, 0, 1)        # Label all features for plotting    classification_params = {    "triple_junctions": tagged_triple_junctions,     "broken_segments": labeled_broken_segments_post3,    "iso_points": tagged_iso_points_post3    }            classified_post3 = classify_pixels(tagged_post3, **classification_params)        return (classified_post3, iso_points_post3, labeled_broken_segments_post3, tagged_iso_points_post3)    # Obtain ideal connection anglesdef ideal_angles(point1, point2):    y1, x1 = point1[0], point1[1]    y2, x2 = point2[0], point2[1]    dy = np.abs(y1-y2)    dx = np.abs(x1-x2)        if y1 > y2:        # theta_1 and theta_2 are the angles within the perpendicular triangle that point1 and point2 forms        theta_1 = np.degrees(np.arctan2(dy,dx))        theta_2 = 90 - theta_1                # alpha_1 and alpha_2 are the angles measured from the 0 line, which lies on +x axis. It depends on where the points are relative to each other.        if x1 > x2:            alpha_1 = 90 + theta_2            alpha_2 = 180 + alpha_1                elif x1 < x2:            alpha_1 = theta_1            alpha_2 = 180 + alpha_1              else: #(x1 == x2)            alpha_1 = 90            alpha_2 = -90                elif y1 < y2:        theta_2 = np.degrees(np.arctan2(dy,dx))        theta_1 = 90 - theta_2                if x1 > x2:            alpha_2 = theta_2            alpha_1 = 180 + alpha_2                elif x1 < x2:            alpha_2 = 90 + theta_1            alpha_1 = 180 + alpha_2        else: #(x1 == x2)            alpha_2 = 90            alpha_1 = -90                else: # (y1 == y2)        if x1 > x2:            alpha_1 = 180            alpha_2 = 0                    elif x1 < x2:            alpha_2 = 180            alpha_1 = 0                       else:            raise ("This should not happen.")        return (alpha_1, alpha_2)# Calculate the cost associated with deviation from the ideal angledef angle_cost(point1, point2, iso_points):    ideal_1, ideal_2 = ideal_angles(point1, point2)     actual_1, actual_2 = iso_points[point1], iso_points[point2]    deviation_1, deviation_2 = np.abs(actual_1 - ideal_1), np.abs(actual_2 - ideal_2)    total_deviation = deviation_1 + deviation_2    return total_deviation# %% Extract field to obtain pair properties (source, sink, and field)def extract_field(image, iso_points, completion_segment, field_size=128):    # Add padding to account for the field created around each isolated point (a 64x64 field requires 32 pixel padding on each side)      pad_size = field_size // 2    padded_image = np.pad(image, pad_size, mode='constant')        # Obtain new padded coordinates for iso_points and completion segment (first point is source, last is sink)    iso_points_padded = {(k[0]+pad_size, k[1]+pad_size): v for k, v in iso_points.items()}    source_padded = (completion_segment[0][0] + pad_size, completion_segment[0][1] + pad_size)    sink_padded = (completion_segment[-1][0] + pad_size, completion_segment[-1][1] + pad_size)        # Check the isolated points associated with the completion segments are actually in the iso_points dict        if (source_padded not in list(iso_points_padded.keys())) or (sink_padded not in list(iso_points_padded.keys())):        raise('The isolated point as part of the completion segment is not actually an isolated point.')            # Assign the absolute coordinate of the source in the padded image    source_abs = {source_padded:iso_points_padded[source_padded]}        # The source is always in the middle of the field    source_rel = {(pad_size, pad_size):iso_points_padded[source_padded]}            # Extract the field    field = padded_image[source_padded[0]-pad_size:source_padded[0]+pad_size, source_padded[1]-pad_size:source_padded[1]+pad_size]        # Assign a different value to the sink in the field for visualization purposes    field[(list(source_rel.keys())[0])] = 5        # Assign the absolute coordinate of the sink in the padded image    sink_abs = {sink_padded:iso_points_padded[sink_padded]}                # Find the relative coordinates of the sinks within the field                       sink_rel = sink_abs_to_rel(list(sink_abs.keys())[0], list(source_abs.keys())[0], list(source_rel.keys())[0])        # Assign a different value to the sink in the field for visualization purposes    field[(sink_rel)] = 5            # Store the field, source point, and sink point    pair = {'field': field, 'source': source_abs, 'sinks': sink_abs}                    return pair 